"""
BPMN XML Parser for Chatbot Conversation Flow

Parses BPMN files generated by our pipeline to extract conversation flow logic.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Set, Tuple
from dataclasses import dataclass
from pathlib import Path


@dataclass
class FlowNode:
    """Represents a BPMN flow node (task, gateway, event)"""
    id: str
    name: str
    node_type: str  # 'startEvent', 'endEvent', 'task', 'exclusiveGateway'
    incoming: List[str]  # List of incoming sequence flow IDs
    outgoing: List[str]  # List of outgoing sequence flow IDs


@dataclass
class SequenceFlow:
    """Represents a BPMN sequence flow"""
    id: str
    name: str
    source_ref: str
    target_ref: str
    condition: Optional[str] = None


@dataclass
class ConversationFlow:
    """Represents the parsed conversation flow from BPMN"""
    start_node: str
    end_nodes: Dict[str, str]  # node_id -> outcome (Home/Clinic/Hospital)
    nodes: Dict[str, FlowNode]
    flows: Dict[str, SequenceFlow]
    decision_gateways: List[str]
    task_modules: Dict[str, str]  # task_id -> module_name


class BPMNParser:
    """Parses BPMN XML files to extract conversation flow logic"""
    
    def __init__(self):
        self.namespaces = {
            'bpmn': 'http://www.omg.org/spec/BPMN/20100524/MODEL'
        }
    
    def parse_bpmn_file(self, bpmn_path: str) -> ConversationFlow:
        """Parse a BPMN file and return conversation flow structure"""
        tree = ET.parse(bpmn_path)
        root = tree.getroot()
        
        # Find the process element
        process = root.find('.//bpmn:process', self.namespaces)
        if process is None:
            raise ValueError("No BPMN process found in file")
        
        # Parse all nodes and flows
        nodes = self._parse_nodes(process)
        flows = self._parse_flows(process)
        
        # Identify special nodes
        start_node = self._find_start_node(nodes)
        end_nodes = self._find_end_nodes(nodes)
        decision_gateways = self._find_decision_gateways(nodes)
        task_modules = self._extract_task_modules(nodes)
        
        return ConversationFlow(
            start_node=start_node,
            end_nodes=end_nodes,
            nodes=nodes,
            flows=flows,
            decision_gateways=decision_gateways,
            task_modules=task_modules
        )
    
    def _parse_nodes(self, process: ET.Element) -> Dict[str, FlowNode]:
        """Parse all flow nodes from the process"""
        nodes = {}
        
        # Parse different types of nodes
        node_types = [
            ('startEvent', 'bpmn:startEvent'),
            ('endEvent', 'bpmn:endEvent'), 
            ('task', 'bpmn:task'),
            ('exclusiveGateway', 'bpmn:exclusiveGateway')
        ]
        
        for node_type, xpath in node_types:
            for element in process.findall(xpath, self.namespaces):
                node_id = element.get('id')
                name = element.get('name', '')
                
                # Get incoming and outgoing sequenceFlow IDs from text content
                # <bpmn:incoming> and <bpmn:outgoing> contain the sequenceFlow IDs as text
                incoming = []
                for inc in element.findall('bpmn:incoming', self.namespaces):
                    if inc is not None and inc.text:
                        t = inc.text.strip()
                        if t:
                            incoming.append(t)
                outgoing = []
                for out in element.findall('bpmn:outgoing', self.namespaces):
                    if out is not None and out.text:
                        t = out.text.strip()
                        if t:
                            outgoing.append(t)
                
                nodes[node_id] = FlowNode(
                    id=node_id,
                    name=name,
                    node_type=node_type,
                    incoming=incoming,
                    outgoing=outgoing
                )
        
        return nodes
    
    def _parse_flows(self, process: ET.Element) -> Dict[str, SequenceFlow]:
        """Parse all sequence flows from the process"""
        flows = {}
        
        for flow_element in process.findall('bpmn:sequenceFlow', self.namespaces):
            flow_id = flow_element.get('id')
            name = flow_element.get('name', '')
            source_ref = flow_element.get('sourceRef')
            target_ref = flow_element.get('targetRef')
            
            # Extract condition if present
            condition = None
            condition_elem = flow_element.find('bpmn:conditionExpression', self.namespaces)
            if condition_elem is not None and condition_elem.text:
                condition = condition_elem.text.strip()
            
            flows[flow_id] = SequenceFlow(
                id=flow_id,
                name=name,
                source_ref=source_ref,
                target_ref=target_ref,
                condition=condition
            )
        
        return flows
    
    def _find_start_node(self, nodes: Dict[str, FlowNode]) -> str:
        """Find the start event node"""
        for node_id, node in nodes.items():
            if node.node_type == 'startEvent':
                return node_id
        raise ValueError("No start event found in BPMN")
    
    def _find_end_nodes(self, nodes: Dict[str, FlowNode]) -> Dict[str, str]:
        """Find end event nodes and map to outcomes"""
        end_nodes = {}
        for node_id, node in nodes.items():
            if node.node_type == 'endEvent':
                # Extract outcome from node name (Home, Clinic, Hospital)
                outcome = node.name if node.name in ['Home', 'Clinic', 'Hospital'] else 'Unknown'
                end_nodes[node_id] = outcome
        return end_nodes
    
    def _find_decision_gateways(self, nodes: Dict[str, FlowNode]) -> List[str]:
        """Find exclusive gateway nodes used for decisions"""
        gateways = []
        for node_id, node in nodes.items():
            if node.node_type == 'exclusiveGateway':
                gateways.append(node_id)
        return gateways
    
    def _extract_task_modules(self, nodes: Dict[str, FlowNode]) -> Dict[str, str]:
        """Extract module names from task nodes"""
        task_modules = {}
        for node_id, node in nodes.items():
            if node.node_type == 'task' and ':' in node.name:
                # Extract module from task name format: "module:rule_id"
                module_name = node.name.split(':')[0]
                task_modules[node_id] = module_name
        return task_modules
    
    def get_outgoing_flows(self, node_id: str, flows: Dict[str, SequenceFlow]) -> List[SequenceFlow]:
        """Get all outgoing flows from a specific node"""
        outgoing_flows = []
        for flow in flows.values():
            if flow.source_ref == node_id:
                outgoing_flows.append(flow)
        return outgoing_flows
    
    def get_next_nodes(self, node_id: str, flows: Dict[str, SequenceFlow]) -> List[str]:
        """Get all nodes that can be reached from the current node"""
        next_nodes = []
        for flow in flows.values():
            if flow.source_ref == node_id:
                next_nodes.append(flow.target_ref)
        return next_nodes
