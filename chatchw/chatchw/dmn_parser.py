"""
DMN XML Parser for Chatbot Decision Logic

Parses DMN files generated by our pipeline to extract decision table logic.
"""

import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass
from pathlib import Path
import re


@dataclass
class InputColumn:
    """Represents a DMN input column"""
    id: str
    label: str
    input_expression: str  # Variable name (e.g., 'temp', 'convulsion')


@dataclass
class OutputColumn:
    """Represents a DMN output column"""
    id: str
    label: str
    name: str


@dataclass
class DecisionRule:
    """Represents a single row in a DMN decision table"""
    id: str
    input_entries: Dict[str, str]  # input_id -> condition text
    output_entries: Dict[str, str]  # output_id -> value


@dataclass
class DecisionTable:
    """Represents a DMN decision table"""
    id: str
    name: str
    hit_policy: str
    input_columns: Dict[str, InputColumn]
    output_columns: Dict[str, OutputColumn]
    rules: List[DecisionRule]


@dataclass
class DecisionLogic:
    """Represents the parsed decision logic from DMN"""
    input_data: Dict[str, str]  # input_id -> variable_name
    decisions: Dict[str, DecisionTable]
    variable_types: Dict[str, str]  # variable -> type (numeric/boolean/string)


class DMNParser:
    """Parses DMN XML files to extract decision logic"""
    
    def __init__(self):
        # Default to DMN 1.4; will auto-detect from document root when parsing
        self.namespaces = {
            'dmn': 'https://www.omg.org/spec/DMN/20191111/MODEL/'
        }
    
    def parse_dmn_file(self, dmn_path: str) -> DecisionLogic:
        """Parse a DMN file and return decision logic structure"""
        tree = ET.parse(dmn_path)
        root = tree.getroot()
        # Auto-detect namespace from root tag if possible
        tag = root.tag
        if '}' in tag:
            ns_uri = tag.split('}', 1)[0].lstrip('{')
            if 'DMN' in ns_uri or 'dmn' in ns_uri or '2015' in ns_uri or '2018' in ns_uri or '2019' in ns_uri:
                self.namespaces['dmn'] = ns_uri
        
        # Parse input data elements
        input_data = self._parse_input_data(root)
        
        # Parse decision tables
        decisions = self._parse_decisions(root)
        
        # Infer variable types from rules
        variable_types = self._infer_variable_types(decisions, input_data)
        
        return DecisionLogic(
            input_data=input_data,
            decisions=decisions,
            variable_types=variable_types
        )
    
    def _parse_input_data(self, root: ET.Element) -> Dict[str, str]:
        """Parse inputData elements to get variable mappings"""
        input_data = {}
        
        for input_elem in root.findall('.//dmn:inputData', self.namespaces):
            input_id = input_elem.get('id')
            name = input_elem.get('name', '')
            
            # Extract variable name from the name attribute
            variable_name = name.lower().replace(' ', '_')
            input_data[input_id] = variable_name
        
        return input_data
    
    def _parse_decisions(self, root: ET.Element) -> Dict[str, DecisionTable]:
        """Parse decision elements and their decision tables"""
        decisions = {}
        
        for decision_elem in root.findall('.//dmn:decision', self.namespaces):
            decision_id = decision_elem.get('id')
            decision_name = decision_elem.get('name', '')
            
            # Find the decision table within this decision
            table_elem = decision_elem.find('.//dmn:decisionTable', self.namespaces)
            if table_elem is not None:
                table = self._parse_decision_table(table_elem, decision_id, decision_name)
                decisions[decision_id] = table
        
        return decisions
    
    def _parse_decision_table(self, table_elem: ET.Element, decision_id: str, decision_name: str) -> DecisionTable:
        """Parse a single decision table"""
        table_id = table_elem.get('id', decision_id)
        hit_policy = table_elem.get('hitPolicy', 'UNIQUE')
        
        # Parse input columns
        input_columns = {}
        for input_elem in table_elem.findall('dmn:input', self.namespaces):
            input_id = input_elem.get('id')
            label = input_elem.get('label', '')
            
            # Get input expression
            expr_elem = input_elem.find('dmn:inputExpression', self.namespaces)
            if expr_elem is not None:
                # Try to get text content directly from inputExpression
                if expr_elem.text and expr_elem.text.strip():
                    input_expression = expr_elem.text.strip()
                else:
                    # Try to find nested text element
                    expr_text = expr_elem.find('dmn:text', self.namespaces)
                    input_expression = expr_text.text.strip() if expr_text is not None and expr_text.text else ''
            else:
                input_expression = ''
            
            input_columns[input_id] = InputColumn(
                id=input_id,
                label=label,
                input_expression=input_expression
            )
        
        # Parse output columns
        output_columns = {}
        for output_elem in table_elem.findall('dmn:output', self.namespaces):
            output_id = output_elem.get('id')
            label = output_elem.get('label', '')
            name = output_elem.get('name', '')
            
            output_columns[output_id] = OutputColumn(
                id=output_id,
                label=label,
                name=name
            )
        
        # Parse rules
        rules = []
        for rule_elem in table_elem.findall('dmn:rule', self.namespaces):
            rule = self._parse_rule(rule_elem, input_columns, output_columns)
            rules.append(rule)
        
        return DecisionTable(
            id=table_id,
            name=decision_name,
            hit_policy=hit_policy,
            input_columns=input_columns,
            output_columns=output_columns,
            rules=rules
        )
    
    def _parse_rule(self, rule_elem: ET.Element, input_columns: Dict[str, InputColumn], 
                   output_columns: Dict[str, OutputColumn]) -> DecisionRule:
        """Parse a single decision rule"""
        rule_id = rule_elem.get('id')
        
        # Parse input entries
        input_entries = {}
        input_elems = rule_elem.findall('dmn:inputEntry', self.namespaces)
        input_ids = list(input_columns.keys())
        
        for i, input_elem in enumerate(input_elems):
            if i < len(input_ids):
                input_id = input_ids[i]
                text_elem = input_elem.find('dmn:text', self.namespaces)
                condition = text_elem.text if text_elem is not None else '-'
                input_entries[input_id] = condition
        
        # Parse output entries
        output_entries = {}
        output_elems = rule_elem.findall('dmn:outputEntry', self.namespaces)
        output_ids = list(output_columns.keys())
        
        for i, output_elem in enumerate(output_elems):
            if i < len(output_ids):
                output_id = output_ids[i]
                text_elem = output_elem.find('dmn:text', self.namespaces)
                value = text_elem.text if text_elem is not None else ''
                output_entries[output_id] = value
        
        return DecisionRule(
            id=rule_id,
            input_entries=input_entries,
            output_entries=output_entries
        )
    
    def _infer_variable_types(self, decisions: Dict[str, DecisionTable], 
                            input_data: Dict[str, str]) -> Dict[str, str]:
        """Infer variable types from decision table rules"""
        variable_types = {}
        
        # Analyze conditions in decision tables to infer types
        for decision in decisions.values():
            for input_col in decision.input_columns.values():
                var_name = input_col.input_expression
                if not var_name:
                    continue
                
                # Look at conditions for this input to infer type
                var_type = self._infer_type_from_conditions(decision, input_col.id)
                variable_types[var_name] = var_type
        
        return variable_types
    
    def _infer_type_from_conditions(self, table: DecisionTable, input_id: str) -> str:
        """Infer variable type by analyzing conditions"""
        conditions = []
        for rule in table.rules:
            if input_id in rule.input_entries:
                condition = rule.input_entries[input_id]
                if condition != '-':
                    conditions.append(condition)
        
        # Analyze condition patterns
        has_numeric = False
        has_boolean = False
        
        for condition in conditions:
            # Check for numeric operators
            if re.search(r'[<>=]|>=|<=', condition):
                if re.search(r'\d+', condition):
                    has_numeric = True
            
            # Check for boolean values
            if re.search(r'\b(true|false)\b', condition.lower()):
                has_boolean = True
        
        if has_numeric:
            return 'numeric'
        elif has_boolean:
            return 'boolean'
        else:
            return 'string'
    
    def evaluate_condition(self, condition: str, variable_value: Any, variable_type: str) -> bool:
        """Evaluate a DMN condition against a variable value"""
        if condition == '-' or not condition:
            return True
        
        try:
            if variable_type == 'boolean':
                return self._evaluate_boolean_condition(condition, variable_value)
            elif variable_type == 'numeric':
                return self._evaluate_numeric_condition(condition, variable_value)
            else:
                return self._evaluate_string_condition(condition, variable_value)
        except:
            return False
    
    def _evaluate_boolean_condition(self, condition: str, value: Any) -> bool:
        """Evaluate boolean condition"""
        condition_lower = condition.lower().strip()
        value_bool = bool(value) if not isinstance(value, bool) else value
        
        # Handle "variable = true/false" patterns
        if '=' in condition_lower:
            parts = condition_lower.split('=', 1)
            if len(parts) == 2:
                expected_val = parts[1].strip()
                if expected_val == 'true':
                    return value_bool is True
                elif expected_val == 'false':
                    return value_bool is False
        
        if condition_lower == 'true':
            return value_bool is True
        elif condition_lower == 'false':
            return value_bool is False
        else:
            return str(value).lower() == condition_lower
    
    def _evaluate_numeric_condition(self, condition: str, value: Any) -> bool:
        """Evaluate numeric condition"""
        try:
            num_value = float(value)
        except:
            return False
        
        # Parse condition like ">= 38.5", "< 115", "= 100"
        condition = condition.strip()
        
        if '>=' in condition:
            threshold = float(condition.split('>=')[1].strip())
            return num_value >= threshold
        elif '<=' in condition:
            threshold = float(condition.split('<=')[1].strip())
            return num_value <= threshold
        elif '>' in condition:
            threshold = float(condition.split('>')[1].strip())
            return num_value > threshold
        elif '<' in condition:
            threshold = float(condition.split('<')[1].strip())
            return num_value < threshold
        elif '=' in condition:
            threshold = float(condition.split('=')[1].strip())
            return num_value == threshold
        else:
            # Try direct equality
            try:
                return num_value == float(condition)
            except:
                return False
    
    def _evaluate_string_condition(self, condition: str, value: Any) -> bool:
        """Evaluate string condition"""
        return str(value).lower() == condition.lower().strip()
    
    def find_matching_rules(self, table: DecisionTable, input_values: Dict[str, Any]) -> List[DecisionRule]:
        """Find all rules that match the given input values"""
        matching_rules = []
        
        for rule in table.rules:
            matches = True

            for input_id, condition in rule.input_entries.items():
                if input_id not in table.input_columns:
                    continue

                var_name = table.input_columns[input_id].input_expression
                cond_text = (condition or '').strip()

                # Skip dash/empty conditions (not constraining)
                if cond_text == '-' or cond_text == '':
                    continue

                # For non-dash conditions, the variable must be present
                if var_name not in input_values:
                    matches = False
                    break

                var_value = input_values[var_name]
                var_type = self._infer_type_from_conditions(table, input_id)

                if not self.evaluate_condition(cond_text, var_value, var_type):
                    matches = False
                    break
            
            if matches:
                matching_rules.append(rule)
        
        return matching_rules
