from __future__ import annotations

import uuid
import xml.etree.ElementTree as ET
from typing import Dict, Iterable, Tuple

from .schema import Rule


BPMN_NS = "http://www.omg.org/spec/BPMN/20100524/MODEL"
BPMNDI_NS = "http://www.omg.org/spec/BPMN/20100524/DI"
DI_NS = "http://www.omg.org/spec/DD/20100524/DI"
DC_NS = "http://www.omg.org/spec/DD/20100524/DC"

ET.register_namespace("bpmn", BPMN_NS)
ET.register_namespace("bpmndi", BPMNDI_NS)
ET.register_namespace("di", DI_NS)
ET.register_namespace("dc", DC_NS)
ET.register_namespace("xsi", "http://www.w3.org/2001/XMLSchema-instance")


def _sid(prefix: str) -> str:
    return f"{prefix}_{uuid.uuid4().hex[:8]}"


def _make_event(parent, kind: str, name: str) -> Tuple[ET.Element, str]:
    eid = _sid(kind.capitalize())
    ev = ET.SubElement(parent, f"{{{BPMN_NS}}}{kind}Event", id=eid, name=name)
    return ev, eid


def _make_task(parent, name: str) -> Tuple[ET.Element, str]:
    tid = _sid("Task")
    t = ET.SubElement(parent, f"{{{BPMN_NS}}}task", id=tid, name=name)
    return t, tid


def _make_gateway(parent, name: str) -> Tuple[ET.Element, str]:
    gid = _sid("Gateway")
    g = ET.SubElement(parent, f"{{{BPMN_NS}}}exclusiveGateway", id=gid, name=name)
    return g, gid


def _make_parallel_gateway(parent, name: str) -> Tuple[ET.Element, str]:
    gid = _sid("ParGateway")
    g = ET.SubElement(parent, f"{{{BPMN_NS}}}parallelGateway", id=gid, name=name)
    return g, gid


def _make_flow(parent, src_id: str, tgt_id: str, name: str, condition: str = None) -> ET.Element:
    fid = _sid("Flow")
    flow = ET.SubElement(
        parent,
        f"{{{BPMN_NS}}}sequenceFlow",
        id=fid,
        name=name,
        sourceRef=src_id,
        targetRef=tgt_id,
    )
    
    # Add condition expression if provided
    if condition:
        cond_expr = ET.SubElement(
            flow,
            f"{{{BPMN_NS}}}conditionExpression",
            attrib={"{http://www.w3.org/2001/XMLSchema-instance}type": "tFormalExpression"},
        )
        cond_expr.text = condition
    
    # Add incoming/outgoing elements to source and target nodes
    # Find source and target elements in parent
    for elem in parent.iter():
        if elem.get('id') == src_id:
            outgoing = ET.SubElement(elem, f"{{{BPMN_NS}}}outgoing")
            outgoing.text = fid
        elif elem.get('id') == tgt_id:
            incoming = ET.SubElement(elem, f"{{{BPMN_NS}}}incoming")
            incoming.text = fid
    
    return flow


def build_bpmn(rulepacks: Dict[str, Iterable]) -> str:
    defs = ET.Element(
        f"{{{BPMN_NS}}}definitions",
        attrib={"id": _sid("Defs"), "targetNamespace": "http://chatchw.local/bpmn"},
    )
    proc = ET.SubElement(defs, f"{{{BPMN_NS}}}process", id=_sid("Process"), isExecutable="false")

    start, start_id = _make_event(proc, "start", "Start")
    
    # Create end events
    end_home, end_home_id = _make_event(proc, "end", "Home")
    end_clinic, end_clinic_id = _make_event(proc, "end", "Clinic") 
    end_hospital, end_hospital_id = _make_event(proc, "end", "Hospital")
    
    # Use a parallel split to distribute work to modules (avoid multiple start outgoings)
    par_split, par_split_id = _make_parallel_gateway(proc, "Prepare Rules (Split)")
    _make_flow(proc, start_id, par_split_id, "start")

    # Join before final decision
    par_join, par_join_id = _make_parallel_gateway(proc, "Rules Completed (Join)")

    # Create main decision gateway after join
    main_gw, main_gw_id = _make_gateway(proc, "Decision Gateway")
    _make_flow(proc, par_join_id, main_gw_id, "to_decision")
    
    # Create flows from main gateway to end events with conditions
    _make_flow(proc, main_gw_id, end_hospital_id, "to_hospital", "danger_sign == true")
    _make_flow(proc, main_gw_id, end_clinic_id, "to_clinic", "clinic_referral == true")
    # Explicit default via unconditional leg; also mark as default on the gateway later
    default_flow = _make_flow(proc, main_gw_id, end_home_id, "to_home")
    
    # Add tasks for each module's rules
    for module_name, rules in rulepacks.items():
        # Create module gateway
        module_gw, module_gw_id = _make_gateway(proc, f"{module_name} Rules")
        _make_flow(proc, par_split_id, module_gw_id, f"check_{module_name}")
        
        # Create tasks for each rule with flows back to main decision
        for r in rules:
            # Handle both Rule objects and dict objects
            rule_id = r.rule_id if hasattr(r, 'rule_id') else r.get('rule_id', 'unknown')
            task, task_id = _make_task(proc, f"{module_name}:{rule_id}")
            
            # Flow from module gateway to task (with condition)
            _make_flow(proc, module_gw_id, task_id, f"apply_{rule_id}", f"{rule_id}_condition")
            
            # Flow from task to parallel join
            _make_flow(proc, task_id, par_join_id, f"after_{rule_id}")
        
        # Default flow from module gateway to the parallel join (no rules match)
        _make_flow(proc, module_gw_id, par_join_id, f"{module_name}_default")

    # Mark the default flow attribute on main gateway
    main_gw.set("default", default_flow.get("id"))

    xml = ET.tostring(defs, encoding="utf-8", xml_declaration=True)
    return xml.decode("utf-8")
